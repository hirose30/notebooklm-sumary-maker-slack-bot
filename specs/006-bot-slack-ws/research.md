# Research: 複数Slackワークスペース対応

## 1. Multi-workspace Slack Bolt Patterns

**Decision**: Single App instance with OAuth + custom InstallationStore (database-backed)

**Rationale**:
- Slack Bolt's recommended approach for multi-workspace support uses OAuth with a custom InstallationStore
- A single App instance can handle multiple workspaces when configured with `authorize` function that retrieves workspace-specific tokens
- This pattern is more scalable than managing multiple App instances (one per workspace)
- The OAuth flow with InstallationStore is the official Slack pattern for distributable apps

**Alternatives Considered**:
1. Multiple App instances (one per workspace): Rejected - doesn't scale well, complex lifecycle management
2. Static token configuration per workspace: Rejected - requires manual OAuth exchange, not maintainable
3. FileInstallationStore: Rejected - only suitable for development, not production

**Implementation Notes**:
- Use `@slack/oauth` package's InstallationStore interface
- Implement three methods: `storeInstallation`, `fetchInstallation`, `deleteInstallation`
- Configure App constructor with: `clientId`, `clientSecret`, `stateSecret`, `scopes`, `installationStore`
- Remove static `token` parameter from App constructor (replaced by authorize function)
- OAuth flow automatically creates `/slack/install` and `/slack/oauth_redirect` endpoints
- The `authorize` function receives `installQuery` (contains teamId, enterpriseId, userId, conversationId, isEnterpriseInstall)

**Key Code Pattern**:
```typescript
const app = new App({
  // Remove: token: config.slackBotToken,
  // Remove: appToken: config.slackAppToken,
  signingSecret: config.slackSigningSecret,
  clientId: config.slackClientId,
  clientSecret: config.slackClientSecret,
  stateSecret: config.slackStateSecret,
  scopes: ['app_mentions:read', 'chat:write', ...],
  installationStore: new SQLiteInstallationStore(db),
  socketMode: true, // Keep for development/testing
  // authorize function is auto-generated by Bolt when installationStore is provided
});
```

## 2. Workspace Configuration Format

**Decision**: Environment variables for OAuth credentials + SQLite database for workspace installations

**Rationale**:
- OAuth credentials (clientId, clientSecret, stateSecret) are app-level secrets → environment variables (following 12-factor app principles)
- Workspace-specific tokens (botToken, appToken per workspace) are installation data → SQLite database via InstallationStore
- No need for JSON/YAML workspace configuration files - installations are managed dynamically through OAuth flow
- Follows Slack's official pattern: OAuth credentials in env vars, installation data in database

**Alternatives Considered**:
1. JSON configuration file with workspace array: Rejected - manual OAuth exchange required, not maintainable at scale
2. YAML configuration file: Rejected - same issue as JSON, plus additional dependency (js-yaml)
3. Separate .env files per workspace: Rejected - doesn't scale, manual management overhead

**Schema Design**:

Environment variables (app-level OAuth credentials):
```bash
SLACK_CLIENT_ID=your_app_client_id
SLACK_CLIENT_SECRET=your_app_client_secret
SLACK_STATE_SECRET=random_secret_for_oauth_state
SLACK_SIGNING_SECRET=your_app_signing_secret
# Remove: SLACK_BOT_TOKEN, SLACK_APP_TOKEN (per-workspace, stored in DB)
```

Database schema (workspace installations):
```sql
CREATE TABLE slack_installations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  team_id TEXT NOT NULL,
  team_name TEXT,
  enterprise_id TEXT,
  enterprise_name TEXT,
  bot_token TEXT NOT NULL,
  bot_id TEXT NOT NULL,
  bot_user_id TEXT NOT NULL,
  bot_scopes TEXT NOT NULL, -- JSON array
  user_token TEXT,
  user_id TEXT,
  user_scopes TEXT, -- JSON array
  installed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(team_id, enterprise_id)
);
```

## 3. Database Migration Strategy

**Decision**: Expand-Migrate-Contract pattern with backward compatibility for existing single-workspace data

**Rationale**:
- Expand-Migrate-Contract is the industry standard for zero-downtime schema changes
- SQLite's ALTER TABLE ADD COLUMN with NULL/DEFAULT ensures backward compatibility
- Existing `requests` table needs `workspace_id` (team_id) column to support multi-workspace
- Migration script can backfill existing data with a default workspace (first installed workspace or env var)

**Alternatives Considered**:
1. Destructive migration (drop and recreate): Rejected - loses existing request history
2. Separate database per workspace: Rejected - complex management, difficult to query across workspaces
3. No migration (new table only): Rejected - doesn't preserve existing data continuity

**Migration Plan**:

Step 1: **Expand** - Add new tables and columns (backward compatible)
```sql
-- Migration 003_multi_workspace.sql

-- New table: slack_installations
CREATE TABLE IF NOT EXISTS slack_installations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  team_id TEXT NOT NULL,
  team_name TEXT,
  enterprise_id TEXT,
  enterprise_name TEXT,
  bot_token TEXT NOT NULL,
  bot_id TEXT NOT NULL,
  bot_user_id TEXT NOT NULL,
  bot_scopes TEXT NOT NULL,
  user_token TEXT,
  user_id TEXT,
  user_scopes TEXT,
  installed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(team_id, enterprise_id)
);

-- Expand: Add workspace_id to existing requests table (nullable for backward compatibility)
ALTER TABLE requests ADD COLUMN workspace_id TEXT;

-- Create index for performance
CREATE INDEX IF NOT EXISTS idx_requests_workspace_id ON requests(workspace_id);
CREATE INDEX IF NOT EXISTS idx_slack_installations_team_id ON slack_installations(team_id);
```

Step 2: **Migrate** - Backfill existing data
```sql
-- Option A: Use environment variable to create default workspace
-- (Implemented in application code during startup)

-- Option B: Leave existing requests with NULL workspace_id
-- (Queries filter by workspace_id, NULL rows are legacy)
```

Step 3: **Contract** - Make workspace_id NOT NULL (future migration after backfill)
```sql
-- Migration 004_workspace_id_not_null.sql (run after all data is backfilled)
-- SQLite doesn't support ALTER COLUMN, so requires table rebuild
-- This migration can be delayed or optional depending on requirements
```

**Rollback Strategy**:
- If new code fails, old code can still read `requests` table (workspace_id column is ignored)
- InstallationStore failures fallback to environment variable tokens (if present)
- Schema version tracking prevents re-applying migrations

## 4. Error Isolation Patterns

**Decision**: AsyncLocalStorage for workspace context + try-catch boundaries per workspace event

**Rationale**:
- AsyncLocalStorage provides request-scoped context without explicit parameter passing
- Each Slack event (app_mention, etc.) runs in its own async context with workspace information
- Try-catch at event handler level prevents one workspace's error from crashing the entire bot
- Database-level isolation via `workspace_id` ensures data separation

**Implementation Notes**:

Context Isolation Pattern:
```typescript
import { AsyncLocalStorage } from 'async_hooks';

interface WorkspaceContext {
  teamId: string;
  teamName: string;
  botToken: string;
}

const workspaceContext = new AsyncLocalStorage<WorkspaceContext>();

// In event handler (set context)
this.app.event('app_mention', async ({ event, client, context }) => {
  const workspace: WorkspaceContext = {
    teamId: context.teamId,
    teamName: context.teamName,
    botToken: context.botToken,
  };

  await workspaceContext.run(workspace, async () => {
    try {
      // All code here has access to workspaceContext.getStore()
      await this.handleMention(event, client);
    } catch (error) {
      logger.error('Error in workspace event', {
        teamId: workspace.teamId,
        error,
      });
      // Error is isolated - doesn't crash other workspaces
    }
  });
});
```

Error Boundary Pattern:
```typescript
private async handleMention(event: any, client: any): Promise<void> {
  const workspace = workspaceContext.getStore();

  try {
    // Workspace-specific processing
    const job = this.queue.addJob(url, event.channel, threadTs, userId, workspace.teamId);
    // ... rest of processing
  } catch (error) {
    // Log with workspace context
    logger.error('Failed to process mention', {
      workspace: workspace.teamId,
      error,
    });

    // Send error response using workspace-specific client
    await client.chat.postMessage({
      channel: event.channel,
      thread_ts: event.ts,
      text: 'エラーが発生しました',
    });
  }
}
```

**Database Isolation**:
- All database queries include `workspace_id` filter
- Foreign key constraints prevent cross-workspace data leaks
- Indexes on `workspace_id` ensure query performance

**Testing Isolation**:
- Integration tests should create separate workspace installations
- Test that errors in workspace A don't affect workspace B
- Validate that data queries are properly scoped by workspace_id

## 5. Configuration Validation

**Decision**: Startup-time validation using custom validator with fail-fast strategy

**Rationale**:
- Validate OAuth credentials at startup before initializing Slack App
- Fail-fast prevents running with incomplete configuration
- Custom validator allows domain-specific checks (e.g., duplicate team_id in database)
- Lightweight approach without external dependencies (Zod, Envalid would be overkill for 4-5 env vars)

**Validation Rules**:

Required Environment Variables:
```typescript
const REQUIRED_ENV_VARS = {
  SLACK_CLIENT_ID: 'Slack app client ID',
  SLACK_CLIENT_SECRET: 'Slack app client secret',
  SLACK_STATE_SECRET: 'Random secret for OAuth state (min 32 chars)',
  SLACK_SIGNING_SECRET: 'Slack app signing secret',
  R2_ACCOUNT_ID: 'Cloudflare R2 account ID',
  R2_ACCESS_KEY_ID: 'Cloudflare R2 access key ID',
  R2_SECRET_ACCESS_KEY: 'Cloudflare R2 secret access key',
  R2_BUCKET_NAME: 'Cloudflare R2 bucket name',
  R2_PUBLIC_URL: 'Cloudflare R2 public URL',
  NOTEBOOKLM_EMAIL: 'NotebookLM account email',
};

// Optional (with defaults)
const OPTIONAL_ENV_VARS = {
  PLAYWRIGHT_HEADLESS: 'true',
  USER_DATA_DIR: './user-data',
};
```

Validation Implementation:
```typescript
function validateConfig(): void {
  const errors: string[] = [];

  // Check required env vars
  for (const [key, description] of Object.entries(REQUIRED_ENV_VARS)) {
    if (!process.env[key] || process.env[key].trim() === '') {
      errors.push(`Missing required environment variable: ${key} (${description})`);
    }
  }

  // Validate state secret length (security requirement)
  if (process.env.SLACK_STATE_SECRET && process.env.SLACK_STATE_SECRET.length < 32) {
    errors.push('SLACK_STATE_SECRET must be at least 32 characters long');
  }

  // Validate URL formats
  if (process.env.R2_PUBLIC_URL && !process.env.R2_PUBLIC_URL.startsWith('https://')) {
    errors.push('R2_PUBLIC_URL must start with https://');
  }

  if (errors.length > 0) {
    logger.error('Configuration validation failed', { errors });
    console.error('\n=== Configuration Validation Errors ===');
    errors.forEach(err => console.error(`  - ${err}`));
    console.error('======================================\n');
    process.exit(1);
  }

  logger.info('Configuration validation passed');
}

// Call at startup (before loading config)
validateConfig();
export const config = loadConfig();
```

Database Validation (at startup):
```typescript
async function validateDatabase(): Promise<void> {
  // Check for duplicate team_id installations (data integrity)
  const duplicates = db.prepare(`
    SELECT team_id, COUNT(*) as count
    FROM slack_installations
    WHERE enterprise_id IS NULL
    GROUP BY team_id
    HAVING count > 1
  `).all();

  if (duplicates.length > 0) {
    logger.error('Duplicate workspace installations detected', { duplicates });
    throw new Error('Database integrity violation: duplicate team_id installations');
  }

  // Check for orphaned requests (workspace_id references non-existent installation)
  const orphaned = db.prepare(`
    SELECT COUNT(*) as count
    FROM requests
    WHERE workspace_id IS NOT NULL
      AND workspace_id NOT IN (SELECT team_id FROM slack_installations)
  `).get() as { count: number };

  if (orphaned.count > 0) {
    logger.warn('Orphaned requests detected (workspace no longer installed)', {
      count: orphaned.count,
    });
    // Warning only - don't fail startup
  }

  logger.info('Database validation passed');
}
```

**Error Messages**:
- Clear, actionable error messages with examples
- Log errors to console (stdout) for visibility in container logs
- Use exit code 1 for configuration failures (enables container restart policies)

**Migration Compatibility Check**:
```typescript
function validateSchemaVersion(): void {
  const currentVersion = db.prepare(
    'SELECT MAX(version) as version FROM schema_version'
  ).get() as { version: number };

  const REQUIRED_VERSION = 3; // Multi-workspace migration

  if (currentVersion.version < REQUIRED_VERSION) {
    logger.error('Database schema version too old', {
      current: currentVersion.version,
      required: REQUIRED_VERSION,
    });
    console.error(`\nDatabase schema version ${currentVersion.version} is too old.`);
    console.error(`Required version: ${REQUIRED_VERSION}`);
    console.error(`Please run migrations before starting the bot.\n`);
    process.exit(1);
  }
}
```
